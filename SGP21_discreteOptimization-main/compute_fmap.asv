function E = compute_fmap(mesh_dir, filename1, filename2, allEdges_source, allEdges_target, pointSize,filename, edgeWidth,quiet)
%%
if (nargin==8)
    quiet = true;
end
k1 = 20; k2 = 20; numTimes = 50; skipSize = 50;
mesh_options = {'IfComputeLB',true,'numEigs',100,... % compute k LB basis
    'IfComputeNormals',true,... % compute vtx normals for orientation term
    'IfComputeGeoDist',false};  % do not compute the geodesic distance matrix
para.beta = 0;
%%

S1 = MESH.MESH_IO.read_shape(strcat(mesh_dir, filename1));
S1 = normalize_mesh_area(S1,1);
S2 = MESH.MESH_IO.read_shape(strcat(mesh_dir, filename2));
S2 = normalize_mesh_area(S2,1);
try
S1 = MESH.preprocess(S1, mesh_options{:});
S2 = MESH.preprocess(S2, mesh_options{:});
catch ME
 E = inf;
 T21_multi = [];
 T21_ours = [];
 return;
end

%% compute WKS descriptors
B1 = S1.evecs(:,1:k1); Ev1 = S1.evals(1:k1);
B2 = S2.evecs(:,1:k2); Ev2 = S2.evals(1:k2);

fct1 = waveKernelSignature(S1.evecs(:,1:100), S1.evals(1:100), S1.A, numTimes);
fct2 = waveKernelSignature(S2.evecs(:,1:100), S2.evals(1:100), S2.A, numTimes);

fct1 = fct1(:,1:skipSize:end);
fct2 = fct2(:,1:skipSize:end);

%use another descriptor

%landmarks for bear;
% landmarks1 = [1659, 1530, 192, 160, 911, 83, 890, 122, 418, 1672, 1577, 8, 222, 1526]';
% landmarks2 = [1092, 692, 939, 1006, 200, 263, 361, 1032, 414, 470, 1459, 14, 532, 693]';

%landmarks for turtle;
% landmarks1 = [3285, 3327, 3260, 598, 3469, 693, 4124, 1355, 3532, 1572, 1585, 3573, 4177, 344, 2109, 1921, 4181, 4182, 4186, 1111, 962, 4287, 3827, 3997, 4274, 4059, 2446]';
% landmarks2 = [321, 325, 387, 1, 15, 203, 3971, 732, 1360, 3863, 4006, 770, 4007, 3776, 860, 4084, 4012, 2149, 4017, 1826, 4122, 1870, 2054, 3128, 4130, 1994, 2649]';

landmarks1 = [];
landmarks2 = [];

% fct1 = waveKernelMap(S1.evecs, S1.evals, S1.A, numTimes, landmarks1);
% fct2 = waveKernelMap(S2.evecs, S2.evals, S2.A, numTimes, landmarks2);
% 
% fct1 = fct1(:,1:skipSize:end);
% fct2 = fct2(:,1:skipSize:end);

% figure;clf;
% subplot(1,2,1); plot_func_on_mesh(S1, fct1); view([0,90])
% subplot(1,2,2); plot_func_on_mesh(S2, fct2); view([0,90])

%% multiplicative term 

para.beta = 0;
[C12_direct, ~, E1] = compute_fMap_regular_with_orientationOp_local(S1,S2,B1,B2,Ev1,Ev2,fct1,fct2,'direct',para);
T21_multi = fMAP.fMap2pMap(B1, B2, C12_direct);

%% Ours
alpha1 =  1e-1; alpha2 = 1e-1;
T21 = knnsearch(fct1, fct2);
Ev2_sum =   cumsum(S2.evals);
for k = 2:20
    B11 = S1.evecs(:,1:k);  Ev11 = S1.evals(1:k);
    B22 = S2.evecs(:,1:k);  Ev22 = S2.evals(1:k);
    Ev11 = Ev11/sum(Ev11); Ev22 = Ev22/sum(Ev22); % normalize the delta to enforce the isometry
    F1 = pinv(B11)*fct1; F2 = pinv(B22)*fct2;
    for iter = 1:5
        C12 = B22\B11(T21,:);
        % descriptor term + Laplacian term + ortho
        T21 = knnsearch( [alpha1*B11*F1,  alpha2*B11*diag(Ev11)*C12', B11*C12'], ....
                                     [alpha1*B22*F2,  alpha2*B22*diag(Ev22),           B22]);
    end
    
    C12 = B22\B11(T21,:);
    T21 = knnsearch(B11*C12', B22);
end
T21_ours= T21;
%E = alpha1*norm(C12*F1-F2,'fro')^2+alpha2*norm(diag(Ev11)*C12-C12*diag(Ev22),'fro')^2;
E = norm(diag(Ev11)*C12-C12*diag(Ev22),'fro')^2;
%%
if ~quiet
f1 = figure('units','normalized','outerposition',[0 0 1 1]); clf;
subplot(1,2,1); 
%visualize_map_on_source(S2, S1, T21_multi, allEdges_source, pointSize, edgeWidth, landmarks1); view([0,90]); %title('Source');
%figure; clf;
subplot(1,2,2); 
visualize_map_on_target(S2, S1, T21_ours, allEdges_target, pointSize, edgeWidth, landmarks2); view([0,90]); %title('Target');
%subplot(1,3,3); visualize_map_on_target(S2, S1, T21_multi); title('Multiplicative Op'); view([0,90])
exportgraphics(f1, strcat('./output/',filename,'_test_fmap.pdf'), 'ContentType','vector');
end
end

